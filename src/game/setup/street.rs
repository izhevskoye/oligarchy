use bevy::prelude::*;
use bevy_ecs_tilemap::prelude::*;
use rand::{thread_rng, Rng};

use crate::game::{
    account::{MaintenanceCost, PurchaseCost},
    assets::{
        resource_specifications::ResourceSpecifications, BlockedForBuilding, CanDriveOver,
        MapSettings, Occupied, Position, RequiresUpdate,
    },
    constants::CHUNK_SIZE,
    helper::get_entity::get_entity,
    pathfinder::{cost_fn, Pathfinding},
    setup::{BUILDING_LAYER_ID, MAP_ID},
    street::Street,
    GenerateStreetEvent, NewGameSetup,
};

// sometimes the noise generates a map where it is impossible to place a street
const MAX_ATTEMPTS: i64 = 20;
const BORDER: u32 = 5;

pub fn generate_street(
    mut commands: Commands,
    street_query: Query<(), With<Street>>,
    occupied_query: Query<(), (With<Occupied>, Without<CanDriveOver>)>,
    blocked_query: Query<(), With<BlockedForBuilding>>,
    mut map_query: MapQuery,
    map_settings: Res<MapSettings>,
    mut events: EventReader<GenerateStreetEvent>,
    resources: Res<ResourceSpecifications>,
    pathfinding: Res<Pathfinding>,
    mut setup: ResMut<Option<NewGameSetup>>,
) {
    for _ in events.iter() {
        let mut random = thread_rng();

        if let Some(pathfinding) = &pathfinding.cache {
            log::info!("Generating street");
            if let Some(mut setup) = setup.as_mut() {
                setup.street = true;
            }

            let mut attempts = 0;

            loop {
                let s_y = random.gen_range(BORDER..map_settings.height * CHUNK_SIZE - 1 - BORDER);
                let d_y = random.gen_range(BORDER..map_settings.height * CHUNK_SIZE - 1 - BORDER);
                let max_x = map_settings.width * CHUNK_SIZE - 2;

                let path = pathfinding.find_path(
                    (0, s_y as usize),
                    (max_x as usize, d_y as usize),
                    cost_fn(&map_query, &street_query, &occupied_query, &blocked_query),
                );

                if let Some(path) = path {
                    let mut points: Vec<UVec2> = path
                        .into_iter()
                        .map(|(x, y)| UVec2::new(x as u32, y as u32))
                        // remove same y on first and last x axis as it looks bad
                        .filter(|point| point.x > 0 && point.x < max_x)
                        .collect();

                    // now add back initial and last point
                    points.insert(0, UVec2::new(0, points[0].y));
                    points.push(UVec2::new(max_x, points[points.len() - 1].y));

                    let mut fixed_points = vec![];
                    let mut i = 0;
                    while i < points.len() {
                        fixed_points.push(points[i]);

                        // smooth out weird U turns generated by the code at times
                        if i + 3 < points.len()
                            && points[i].y == points[i + 3].y
                            && points[i].x + 1 == points[i + 3].x
                        {
                            i += 2;
                        }

                        i += 1;
                    }

                    for pos in fixed_points {
                        let price = Street::default().price(&resources);
                        let entity =
                            get_entity(&mut commands, &mut map_query, pos, BUILDING_LAYER_ID);

                        // TODO: bundle
                        commands
                            .entity(entity)
                            .insert(Street)
                            .insert(RequiresUpdate)
                            .insert(MaintenanceCost::new_from_cost(price))
                            .insert(Position { position: pos })
                            .insert(CanDriveOver)
                            .insert(Occupied);

                        map_query.notify_chunk_for_tile(pos, MAP_ID, BUILDING_LAYER_ID);
                    }

                    break;
                }

                attempts += 1;
                if attempts > MAX_ATTEMPTS {
                    break;
                }
            }
        }
    }
}
